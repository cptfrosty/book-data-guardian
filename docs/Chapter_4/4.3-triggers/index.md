# Триггеры в PostgreSQL

**Тип занятия:** лекция

**Продолжительность:** 2 академических часа

## 1. Что такое триггер

**Триггер (Trigger)** — это механизм автоматического выполнения функции при наступлении определённого события в таблице.

Триггер срабатывает:

- при INSERT
- при UPDATE
- при DELETE
- при TRUNCATE

## 2. Зачем нужны триггеры

Триггеры применяются для:

- автоматической проверки данных
- реализации бизнес-правил
- ведения журнала изменений
- автоматического расчёта значений
- обеспечения сложной целостности

> Главное свойство: триггер выполняется автоматически, без явного вызова.

## 3. Архитектура триггера

Триггер состоит из двух частей:

- Функция (trigger function) — содержит логику
- Сам триггер — привязывает функцию к событию

## 4. Синтаксис создания функции-триггера

```sql
CREATE FUNCTION function_name()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- логика
    RETURN NEW;
END;
$$;
```

Возвращаемое значение:

- NEW — новая строка
- OLD — старая строка
- NULL — отмена операции

## 5. Создание триггера

```sql
CREATE TRIGGER trigger_name
BEFORE INSERT ON table_name
FOR EACH ROW
EXECUTE FUNCTION function_name();
```

## 6. BEFORE и AFTER

|Тип        |	Когда выполняется   |
|-----------|-----------------------|
|BEFORE     |	До изменения данных |
|AFTER      |	После изменения     |

- BEFORE можно изменить данные
- AFTER используется для логирования


## 7. FOR EACH ROW vs FOR EACH STATEMENT
|Тип                |	Особенность                     |
|-------------------|-----------------------------------|
|FOR EACH ROW       |	Выполняется для каждой строки   |
|FOR EACH STATEMENT |	Один раз для всей операции      |

## 8. NEW и OLD

При:

- INSERT → доступен NEW
- UPDATE → доступны NEW и OLD
- DELETE → доступен OLD

Пример:

```sql
RAISE NOTICE 'Старое значение: %, Новое значение: %', OLD.salary, NEW.salary;
```

## 9. Пример 1: Автоматическая установка даты

```sql
CREATE FUNCTION set_created_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.created_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_set_created_at
BEFORE INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION set_created_at();
```

## 10. Пример 2: Контроль бизнес-логики

Запретить уменьшение зарплаты:

```sql
CREATE FUNCTION prevent_salary_decrease()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF NEW.salary < OLD.salary THEN
        RAISE EXCEPTION 'Запрещено уменьшать зарплату';
    END IF;

    RETURN NEW;
END;
$$;
```

## 11. Пример 3: Логирование изменений

```sql
CREATE TABLE salary_log (
    employee_id INT,
    old_salary NUMERIC,
    new_salary NUMERIC,
    changed_at TIMESTAMP
);
```


Триггер:

```sql
CREATE FUNCTION log_salary_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO salary_log
    VALUES (OLD.id, OLD.salary, NEW.salary, CURRENT_TIMESTAMP);

    RETURN NEW;
END;
$$;
```

## 12. Удаление триггера

```sql
DROP TRIGGER trigger_name ON table_name;
```

## 13. WHEN (условие триггера)

Можно добавить условие:

```sql
CREATE TRIGGER trg_salary_update
AFTER UPDATE ON employees
FOR EACH ROW
WHEN (OLD.salary IS DISTINCT FROM NEW.salary)
EXECUTE FUNCTION log_salary_change();
```

> Триггер выполнится только при изменении зарплаты.


## 14. Порядок выполнения

При INSERT:

- BEFORE-триггер
- Проверка ограничений
- Вставка
- AFTER-триггер

## 15. Типичные ошибки студентов
|Ошибка                                 |	Причина                         |
|---------------------------------------|-----------------------------------|
|Забытый RETURN NEW                     |	Ошибка выполнения               |
|Использование OLD в INSERT             |	Недоступно                      |
|Бесконечная рекурсия                   |	Триггер изменяет ту же таблицу  |
|Логика, которую можно реализовать CHECK|	Избыточность                    |

## 16. Когда использовать триггеры

Использовать:

- при сложных бизнес-правилах
- при автоматическом логировании
- при поддержании сложной целостности

Не использовать:

- если можно обойтись ограничениями
- если логика принадлежит приложению
- если требуется прозрачность

17. Производительность и риски

Триггеры:

- увеличивают нагрузку
- усложняют отладку
- могут скрывать логику

> Важно документировать триггеры.

18. Выводы

Триггеры:

- реализуют автоматическую реакцию на события
- тесно связаны с PL/pgSQL
- используются для бизнес-логики и контроля
- требуют осторожного проектирования

## Домашнее задание

### Задание 1.

Создать триггер автоматически заполняющий `created_at` при вставке нового сотрудника

Использовать BEFORE INSERT.

Проверить, что дата устанавливается автоматически.

### Задание 2.

Создать триггер запрещающий уменьшение зарплаты, при попытке уменьшить — выбрасывать RAISE EXCEPTION

Использовать OLD и NEW.

### Задание 3

Создать триггер записывающий изменения зарплаты в таблицу `salary_log` с указанием времени изменения

Добавить условие WHEN, чтобы логирование происходило только при реальном изменении зарплаты.

### Задание 4

Создать триггер при добавлении заказа автоматически проверять если `total_amount > 100000` установить клиенту статус 'VIP'

Использовать UPDATE внутри триггерной функции.

### Задание 5

Создать триггер при удалении сотрудника записывать информацию в таблицу `employee_archive` запрещать удаление, если сотрудник руководит отделом

Использовать:

- OLD
- условную проверку
- RAISE EXCEPTION

## Контрольные вопросы

1. Что такое триггер и из каких двух частей он состоит?
2. В чём разница между BEFORE и AFTER триггером?
3. Чем отличается FOR EACH ROW от FOR EACH STATEMENT?
4. Когда доступны NEW и OLD?
5. Почему триггеры могут усложнять сопровождение БД?
6. В каком порядке выполняются триггеры, ограничения, сама операция?
7. Почему иногда лучше использовать CHECK, а не триггер?
8. Что может вызвать бесконечную рекурсию триггера?