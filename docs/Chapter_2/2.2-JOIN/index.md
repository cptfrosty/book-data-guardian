# JOIN — соединение таблиц в SQL

**Тип занятия:** лекция

**Продолжительность:** 2 академических часа

## 1. Зачем нужен JOIN

Реляционная модель предполагает нормализацию данных, информация хранится в нескольких связанных таблицах.

Чтобы получить связанную информацию, используется операция соединения — JOIN.

JOIN объединяет строки из двух таблиц по условию связи.

## 2. Исходная модель для примеров

```sql
CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    full_name TEXT NOT NULL,
    department_id INT REFERENCES departments(id)
);
```

## 3. Виды JOIN

### INNER JOIN
Возвращает только строки, для которых есть совпадение в обеих таблицах.

```sql
SELECT e.full_name, d.name
FROM employees e
INNER JOIN departments d
    ON e.department_id = d.id;
```

Если сотрудник не привязан к отделу — он не попадёт в результат.

### LEFT JOIN (LEFT OUTER JOIN)

Возвращает все строки из левой таблицы + совпадения справа.

```sql
SELECT e.full_name, d.name
FROM employees e
LEFT JOIN departments d
    ON e.department_id = d.id;
```

Если отдела нет — `d.name = NULL`.

### RIGHT JOIN
Возвращает все строки из правой таблицы.

```sql
SELECT e.full_name, d.name
FROM employees e
RIGHT JOIN departments d
    ON e.department_id = d.id;
```

Используется редко — чаще таблицы меняют местами и используют LEFT JOIN.

### FULL JOIN
Возвращает:

- совпадающие строки
- несвязанные строки слева
- несвязанные строки справа

```sql
SELECT e.full_name, d.name
FROM employees e
FULL JOIN departments d
    ON e.department_id = d.id;
```

## 4. Визуальная логика JOIN
|Тип JOIN   | Что возвращает            |
|-----------|---------------------------|
|INNER      | Только пересечение        |
|LEFT       | Всё слева + совпадения    |
|RIGHT      | Всё справа + совпадения   |
|FULL       | Всё                       |

## Условие соединения (ON)

Критически важный элемент:

```sql
ON e.department_id = d.id
```

Ошибка в условии = логическая ошибка в результате.

## 6. JOIN нескольких таблиц

```sql
SELECT e.full_name, d.name, f.name
FROM employees e
JOIN departments d ON e.department_id = d.id
JOIN faculties f ON d.faculty_id = f.id;
```

Соединения выполняются последовательно.

## 7. JOIN и WHERE — принципиальная разница

```sql
SELECT *
FROM employees e
LEFT JOIN departments d
    ON e.department_id = d.id
WHERE d.name = 'IT';
```

Такой запрос фактически превращается в INNER JOIN.

Почему?
Потому что строки с NULL отфильтруются в WHERE.

Правильный вариант:

```sql
LEFT JOIN departments d
    ON e.department_id = d.id
    AND d.name = 'IT';
```

## 8. JOIN без условия (CROSS JOIN)

```sql
SELECT *
FROM employees
CROSS JOIN departments;
```

Возвращает декартово произведение.

Опасно при больших таблицах.

## 9. Типичные ошибки

|Ошибка                         |	Последствие             |
|-------------------------------|---------------------------|
|Отсутствие ON                  |	Декартово произведение  |
|Фильтрация в WHERE вместо ON   |	Потеря строк            |
|Неправильный порядок JOIN      |	Логическая ошибка       |
|SELECT *                       |	Избыточные данные       |

## 10. Производительность JOIN

JOIN опирается на:

- индексы
- план выполнения (`EXPLAIN`)
- размер таблиц

Отсутствие индекса по внешнему ключу замедляет запрос.

## 11. Итоги

JOIN:

- связывает нормализованные данные
- формирует логическое представление
- требует точного условия соединения
- влияет на производительность

## Домашнее задание №1
Создайте таблицы:

- students (id, full_name, group_id)
- groups (id, name, curator)
- teachers (id, full_name)

Свяжите:

- students.group_id → groups.id

Напишите запросы:

- Вывести список студентов с названием группы.
- Вывести всех студентов, включая тех, у кого нет группы.
- Вывести группы без студентов.
- Вывести количество студентов в каждой группе.
- Вывести группы, где больше 2 студентов.

## Домашнее задание №2

Создайте таблицы:

- orders
- clients

Связь: заказ принадлежит клиенту.

Выполните:

- Запрос с INNER JOIN
- Запрос с LEFT JOIN
- Добавьте условие фильтрации клиента в WHERE
- Перенесите это же условие в ON

Ответьте:

- Почему результат отличается?
- Когда LEFT JOIN фактически превращается в INNER JOIN?

## Домашнее задание №3

Создайте модель:

- faculties
- departments
- teachers
- courses

Связи:

факультет → кафедра → преподаватель → курс

Напишите запрос:

Получить список:

- курс
- преподаватель
- кафедра
- факультет

Найти курсы без преподавателей.

Найти факультеты без кафедр.

Обязательное условие использовать минимум 3 JOIN в одном запросе.

## Контрольные вопросы

1. В чём логическая разница между INNER JOIN и LEFT JOIN?
2. Почему условие в WHERE может изменить поведение LEFT JOIN?
3. Что произойдёт, если выполнить JOIN без условия ON?
4. Почему RIGHT JOIN используется редко?
5. Как JOIN влияет на производительность запроса?
6. Можно ли соединить таблицы без внешнего ключа?