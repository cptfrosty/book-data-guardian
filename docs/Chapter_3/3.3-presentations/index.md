# Представления (VIEW) в SQL

**Тип занятия:** лекция

**Продолжительность:** 2 академических часа

## 1. Что такое представление (VIEW)

**Представление (VIEW)** — это виртуальная таблица, основанная на результате SELECT-запроса.

> VIEW не хранит данные, а хранит SQL-запрос.

При обращении к представлению СУБД выполняет его запрос.

## 2. Зачем нужны представления

VIEW используются для:

- упрощения сложных запросов
- повторного использования логики
- ограничения доступа к данным
- абстрагирования структуры БД
- создания слоя логики внутри БД

## 3. Синтаксис создания VIEW

```sql
CREATE VIEW view_name AS
SELECT ...
FROM ...
WHERE ...;
```

Пример:

```sql
CREATE VIEW client_totals AS
SELECT c.id,
       c.full_name,
       SUM(oi.quantity * oi.price) AS total
FROM clients c
JOIN orders o ON o.client_id = c.id
JOIN order_items oi ON oi.order_id = o.id
GROUP BY c.id, c.full_name;
```

Теперь можно:

```sql
SELECT *
FROM client_totals
WHERE total > 100000;
```

## 4. Логика работы VIEW

Когда выполняется:

```sql
SELECT * FROM client_totals;
```

СУБД фактически выполняет исходный SELECT, прописанный в VIEW.

> VIEW — это «сохранённый SELECT»

## 5. Обновляемые представления

В PostgreSQL представление может быть обновляемым, если:

- используется одна таблица
- нет агрегатов
- нет GROUP BY
- нет DISTINCT
- нет JOIN

Пример обновляемого VIEW:

```sql
CREATE VIEW active_clients AS
SELECT *
FROM clients
WHERE status = 'active';
```

Можно выполнить:

```sql
UPDATE active_clients
SET city = 'Москва'
WHERE id = 5;
```

## 6. Когда VIEW нельзя обновлять

Если представление содержит:

- JOIN
- агрегаты
- GROUP BY
- HAVING
- подзапросы

то оно становится только для чтения.

## 7. VIEW vs CTE

|VIEW                                   |CTE                                    |
|---------------------------------------|---------------------------------------|
|Сохраняется в БД                       |   Существует в рамках одного запроса  |
|Повторно используется                  |	Временная конструкция               |
|Подходит для логического слоя          |	Подходит для этапов запроса         |
|Может использоваться для прав доступа  |	Нет                                 |

## 8. VIEW и безопасность

Можно предоставить доступ:

```sql
GRANT SELECT ON client_totals TO analyst;
```

Пользователь получит доступ к представлению, но не к исходным таблицам.

> Это способ ограничения данных.

## 9. MATERIALIZED VIEW

В PostgreSQL существует материализованное представление:

```sql
CREATE MATERIALIZED VIEW sales_summary AS
SELECT ...
```

Отличие:

|VIEW               |	MATERIALIZED VIEW   |
|-------------------|-----------------------|
|Данные не хранятся | Данные сохраняются    |
|Всегда актуальны | | Требуют обновления    |
|Быстрее создание   | Быстрее чтение        |

Обновление:

```sql
REFRESH MATERIALIZED VIEW sales_summary;
```

## 10. Изменение и удаление VIEW

Изменение

```sql
CREATE OR REPLACE VIEW view_name AS
SELECT ...
```

Удаление

```sql
DROP VIEW view_name;
```

## 11. Типичные ошибки

|Ошибка                             |Причина                |
|-----------------------------------|-----------------------|
|Ожидание хранения данных           |	VIEW — не таблица   |
|Попытка UPDATE сложного VIEW       |	Ограничения         |
|Игнорирование производительности   |	Сложный SELECT      |
|Злоупотребление VIEW               |	Усложнение схемы    |

## 12. Когда использовать VIEW

Использовать, если:

- сложный аналитический запрос используется часто
- требуется логическое разделение слоёв
- нужно ограничить доступ
- нужно скрыть структуру БД

Не использовать, если:

- запрос используется один раз
- требуется максимальная производительность
- логика часто меняется

## 13. Архитектурный аспект

В промышленной разработке VIEW часто:

- формируют аналитический слой
- используются BI-инструментами
- служат интерфейсом между БД и приложением

## 14. Выводы

Представления:

- упрощают сложные SELECT
- позволяют строить логический слой БД
- помогают управлять доступом
- не хранят данные (кроме materialized view)
- являются важным инструментом архитектуры

## Домашнее задание

Представленная модель:

- clients
- orders
- order_items

### Задание 1

Создать представление client_totals, которое содержит:

- id клиента
- ФИО
- количество заказов
- общую сумму заказов

Выполнить запрос: вывести клиентов с суммой более 100 000.

> Запрещено повторно писать агрегатный запрос во внешнем SELECT.

### Задание 2

Создать представление client_public_info, которое содержит:

- id
- ФИО
- город

Объясните почему это безопаснее, чем давать доступ к таблице clients.

Предложить, какие столбцы нельзя включать в публичное представление.

### Задание 3

Создать представление active_clients только клиенты со статусом 'active'.

Выполнить через представление:

- UPDATE одного клиента.

Проверить, изменилась ли исходная таблица.

> Объяснить, почему представление обновляемое.

### Задание 4

Создать MATERIALIZED VIEW sales_summary, которая содержит сумму продаж по месяцам.

Добавить новые данные в таблицы.

Проверить, изменился ли результат в materialized view.

Выполнить REFRESH MATERIALIZED VIEW.

> Объяснить разницу между VIEW и MATERIALIZED VIEW.

## Контрольные вопросы
1. Что такое представление и хранит ли оно данные?
2. В чём отличие VIEW от CTE?
3. Когда представление становится необновляемым?
4. Чем отличается VIEW от MATERIALIZED VIEW?
5. Как представления используются для ограничения доступа к данным?
6. Можно ли изменить представление?
7. Почему чрезмерное использование VIEW может ухудшить производительность?
8. В каком случае лучше использовать CTE вместо VIEW?