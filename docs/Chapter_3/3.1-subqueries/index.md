# Подзапросы

## 1. Понятие подзапроса

**Подзапрос** — это вложенный SELECT, который используется внутри другого SQL-оператора.

Он может быть размещён в:

- `WHERE`
- `SELECT`
- `FROM`
- `HAVING`
- `INSERT`
- `UPDATE`
- `DELETE`

Подзапрос позволяет выполнить промежуточное вычисление и использовать его результат в основном запросе.

## 2. Классификация подзапросов

### По количеству возвращаемых строк

|Тип            |Характеристика                         |
|---------------|---------------------------------------|
|Скалярный      | возвращает одно значение              |
|Множественный  | возвращает несколько строк            |
|Табличный      | используется как временная таблица    |

### По зависимости от внешнего запроса

|Тип                | Особенность                                       |
|-------------------|---------------------------------------------------|
|Некоррелированный  | выполняется один раз                              |
|Коррелированный    | выполняется для каждой строки внешнего запроса    |

## 3. Скалярные подзапросы

Возвращают одно значение.

```sql
SELECT full_name, salary
FROM employees
WHERE salary > (
    SELECT AVG(salary)
    FROM employees
);
```

Логика выполнения:

- Сначала вычисляется средняя зарплата.

- Затем выполняется внешний запрос.

> Если подзапрос возвращает более одного значения — возникает ошибка.

## 4. Подзапросы с несколькими значениями

Используются операторы:

- IN
- ANY
- ALL

### IN

```sql
SELECT full_name
FROM employees
WHERE department_id IN (
    SELECT id
    FROM departments
    WHERE name = 'IT'
);
```

Проверяется принадлежность к множеству значений.

### ANY / ALL

```sql
WHERE salary > ALL (subquery)
```

`ALL` — условие выполняется для всех значений

`ANY` — условие выполняется хотя бы для одного значения


## 5. EXISTS

Проверяет существование строки.

```sql
SELECT full_name
FROM clients c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.client_id = c.id
);
```

Особенности:

- Возвращает TRUE при наличии хотя бы одной строки.
- Игнорирует возвращаемые значения.
- Часто эффективнее `IN`.

## 6. Коррелированные подзапросы

Внутренний запрос зависит от внешнего.

```sql
SELECT c.full_name,
       (SELECT COUNT(*)
        FROM orders o
        WHERE o.client_id = c.id) AS order_count
FROM clients c;
```

Механизм:

- Для каждой строки clients выполняется подзапрос

> Может приводить к ухудшению производительности.

## 7. Подзапрос в FROM (производная таблица)

```sql
SELECT department_id, avg_salary
FROM (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
) t
WHERE avg_salary > 50000;
```

Особенности:

- Формирует временный результат
- Требует псевдоним (`AS t`)

## 8. Подзапрос в SELECT

```sql
SELECT full_name,
       (SELECT AVG(salary)
        FROM employees) AS avg_salary
FROM employees;
```

> Вычисляет значение и выводит его в каждой строке.

## 9. Подзапросы в DML

### В INSERT

```sql
INSERT INTO archive_employees
SELECT *
FROM employees
WHERE salary < 30000;
```

### В UPDATE

```sql
UPDATE employees
SET salary = salary * 1.1
WHERE department_id IN (
    SELECT id
    FROM departments
    WHERE name = 'IT'
);
```

## 10. Подзапрос vs JOIN

Когда лучше подзапрос:

- при сравнении с агрегатом

- при логике «больше среднего»

- при проверке существования

Когда лучше JOIN:

- при объединении таблиц

- при выводе данных из нескольких таблиц

- при аналитике

> Оптимизатор PostgreSQL часто преобразует подзапрос в JOIN.

## 11. Типичные ошибки

|Ошибка                                 | Причина                   |
|---------------------------------------|---------------------------|
|Подзапрос возвращает более одной строки| Используется как скалярный|
|Использование агрегата без подзапроса  | Нарушение логики          |
|Путаница EXISTS и IN                   | Различие в механике       |
|Игнорирование производительности       | Коррелированный подзапрос |

## 12. Порядок выполнения

Логически:

- Выполняется подзапрос (если некоррелированный)
- Выполняется внешний запрос
- При корреляции — подзапрос выполняется многократно

## 13. Выводы

Подзапросы:

- расширяют выразительность SQL
- позволяют строить сложные аналитические запросы
- бывают зависимыми и независимыми
- могут влиять на производительность
- часто могут быть переписаны через JOIN

## Домашнее задание

Работаем с моделью:

- clients
- orders
- order_items

### Задание 1.

- Найти клиентов, у которых сумма заказов выше средней по всем клиентам.
- Найти заказ с максимальной суммой.
- Найти клиентов, чей средний чек выше общего среднего чека.

> использовать подзапрос в WHERE или HAVING.

### Задание 2. 

- Найти клиентов из городов, где есть заказы более 100 000.
- Найти клиентов, чья сумма заказов больше, чем у всех клиентов из определённого города (использовать ALL).
- Найти клиентов, у которых есть заказ дороже хотя бы одного заказа другого клиента (использовать ANY).

> объяснить разницу между ANY и ALL.

### Задание 3.

- Найти клиентов, у которых есть заказы.
- Найти клиентов, у которых нет заказов.
- Переписать оба запроса через LEFT JOIN.

Сравнить логику и читаемость.

### Задание 4.

Для каждого клиента вывести:

- количество заказов
- сумму заказов (через подзапрос в SELECT)

Переписать этот запрос через JOIN + GROUP BY.

Вопрос: какой вариант читабельный, какой потенциально производительнее и почему?

## Контрольные вопросы

1. Что такое подзапрос и в каких частях SQL-запроса он может использоваться?
2. В чём разница между скалярным и множественным подзапросом?
3. Чем отличается IN от EXISTS?
4. Что такое коррелированный подзапрос?
5. В чём разница между ANY и ALL?
6. Почему подзапрос часто можно переписать через JOIN?
7. В каком порядке логически выполняется подзапрос?