# EXPLAIN ANALYZE

**Тип:** лекция

## 1. Зачем нужен EXPLAIN

Когда запрос работает медленно, возникает вопрос:

- Что именно делает СУБД при выполнении запроса?

Ответ: Команда EXPLAIN показывает план выполнения запроса — то есть стратегию, выбранную оптимизатором.

## 2. EXPLAIN vs EXPLAIN ANALYZE

### EXPLAIN

```sql
EXPLAIN SELECT * FROM employees WHERE salary > 100000;
```

- Показывает предполагаемый план
- Запрос НЕ выполняется

```sql
EXPLAIN ANALYZE
EXPLAIN ANALYZE SELECT * FROM employees WHERE salary > 100000;
```

- Выполняет запрос
- Показывает фактическое время выполнения
- Показывает реальное количество строк

> Для анализа производительности используется именно EXPLAIN ANALYZE.

## 3. Основные элементы плана

Пример:

```sql
Seq Scan on employees
  (cost=0.00..431.00 rows=100 width=48)
  (actual time=0.020..5.120 rows=120 loops=1)
```

## 4. Разбор параметров

### cost

```sql
cost=0.00..431.00
```

- Оценка оптимизатора
- Не реальное время
- Внутренние единицы стоимости

### rows

```sql
rows=100
```

Ожидаемое количество строк

### actual rows

```sql
actual rows=120
```

Реальное количество строк

> Если сильно отличается — статистика устарела.

### actual time

```sql
actual time=0.020..5.120
```

Время начала и окончания операции

## 5. Основные типы операций

### Seq Scan (Sequential Scan)

Полное сканирование таблицы.

```sql
Seq Scan on employees
```

Используется если:

- нет индекса
- таблица маленькая
- условие не селективное

### Index Scan

Поиск через индекс.

```sql
Index Scan using idx_salary on employees
```

Быстрее при селективных условиях.

### Bitmap Index Scan

Используется при:

- большом количестве совпадений
- сложных условиях

Комбинируется с:

```sql
Bitmap Heap Scan
```

### Nested Loop

Соединение таблиц.

Подходит для:

- маленьких таблиц
- индексированных JOIN

### Hash Join

Создаётся хеш-таблица.

Используется при:

- больших таблицах
- отсутствии индекса

### Merge Join

Требует отсортированные данные.

Используется если:

- есть индексы
- данные уже отсортированы

## 6. Порядок чтения плана

План читается снизу вверх.

Пример:

```sql
Nested Loop
  -> Seq Scan on clients
  -> Index Scan on orders
```

Сначала выполняется нижняя операция, затем верхняя.

## 7. Пример анализа

Запрос:

```sql
SELECT *
FROM orders
WHERE client_id = 10;
```

Без индекса → Seq Scan
С индексом → Index Scan

> Сравнение через EXPLAIN ANALYZE показывает реальную разницу.

## 8. ANALYZE и статистика

Оптимизатор опирается на статистику.

Если статистика устарела:

```sql
ANALYZE table_name;
```

или

```sql
VACUUM ANALYZE;
```

## 9. BUFFERS

```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT ...
```

Показывает:

- чтения из памяти
- чтения с диска

Помогает выявить I/O-проблемы.

## 10. FORMAT JSON

```sql
EXPLAIN (ANALYZE, FORMAT JSON) SELECT ...
```

Используется:

- для инструментов анализа
- для визуализации плана

## 11. Типичные проблемы

|Проблема                       |	Причина             |
|-------------------------------|---------------------|
|Seq Scan на большой таблице    |	Нет индекса         |
|Большой разрыв rows/actual rows|	Плохая статистика   |
|Nested Loop на больших таблицах|	Неоптимальный план  |
|Долгий Hash Join               |	Недостаточно памяти |

## 12. Когда использовать EXPLAIN ANALYZE

- медленный `SELECT`
- сложный `JOIN`
- GROUP BY
- проблемы с индексами
- оптимизация аналитики

## 13. Важные принципы

- Не ориентироваться только на cost
- Сравнивать actual rows и rows
- Анализировать тип сканирования
- Проверять использование индекса
- Сначала понимать запрос, потом оптимизировать

## 14. Частые ошибки студентов
Ошибка	Причина
Смотрят только на время	Игнорируют план
Не понимают порядок операций	Читают сверху вниз
Создают индекс без анализа	Нет понимания селективности
Не обновляют статистику	Некорректные планы

## 15. Архитектурный вывод

EXPLAIN ANALYZE — основной инструмент:

- DBA
- backend-разработчика
- аналитика

Он показывает:

- как думает оптимизатор
- почему запрос медленный
- где узкое место

## 16. Выводы

EXPLAIN ANALYZE:

- показывает реальный план выполнения
- помогает выявить неэффективные операции
- необходим для оптимизации
- требует понимания индексов и JOIN

## Домашнее задание

Предметная область

```sql
employees (id SERIAL PRIMARY KEY, full_name TEXT, salary NUMERIC, department TEXT);
clients (id SERIAL PRIMARY KEY, full_name TEXT, city TEXT, status TEXT);
orders (id SERIAL PRIMARY KEY, client_id INT, order_date DATE, total_amount NUMERIC);
```

> Заполнить таблицы минимум 20 000 строк для анализа

## Задание 1. Seq Scan vs Index Scan

Выполнить:

```sql
EXPLAIN ANALYZE
SELECT * FROM employees WHERE salary > 100000;
```

Создать индекс по salary.

Повторить анализ.

> Ответить: какой тип сканирования используется? как изменилось время? почему?

## Задание 2. JOIN и тип соединения

Выполнить:

```sql
EXPLAIN ANALYZE
SELECT *
FROM orders o
JOIN clients c ON c.id = o.client_id;
```

> Ответить: используется Nested Loop, Hash Join или Merge Join? почему выбран именно этот тип? как повлияет индекс на orders.client_id?

## Задание 3. Ошибка оценки строк

Выполнить запрос с фильтрацией по редко встречающемуся значению.

Сравнить:

- rows
- actual rows

Выполнить:

```sql
ANALYZE table_name;
```

Повторить `EXPLAIN ANALYZE`.

> Объяснить влияние статистики.

## Задание 4. Bitmap Scan

Создать индекс и выполнить запрос с условием:

```sql
WHERE salary > 50000 AND department = 'IT';
```

> Ответить: используется ли Bitmap Index Scan? почему не Index Scan?

## Задание 5 

Найти медленный запрос (с JOIN + GROUP BY).

Проанализировать план.

Предложить:

- индекс
- переписывание запроса
- изменение структуры

> Обосновать выбор.

## Контрольные вопросы

1. В чём разница между EXPLAIN и EXPLAIN ANALYZE?
2. Что означает параметр cost?
3. Почему важно сравнивать rows и actual rows?
4. Что такое Seq Scan и когда он допустим?
5. Чем отличается Index Scan от Bitmap Index Scan?
6. Какой тип JOIN используется чаще всего для больших таблиц?
7. Почему оптимизатор может не использовать индекс?
8. Как обновить статистику таблицы?
9. Почему план читается снизу вверх?
10. Почему нельзя ориентироваться только на время выполнения?