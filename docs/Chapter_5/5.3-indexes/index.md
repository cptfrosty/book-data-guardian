# Индексы

**Тип:** лекция

## 1. Что такое индекс

**Индекс** — это вспомогательная структура данных, предназначенная для ускорения поиска строк в таблице.

> Аналогия: индекс в БД — это как оглавление в книге.

Без индекса:

- выполняется последовательное сканирование
- проверяется каждая строка

С индексом:

- используется индексное сканирование
- происходит быстрый поиск по ключу

## 2. Зачем нужны индексы

Индексы ускоряют:

- WHERE
- JOIN
- ORDER BY
- GROUP BY
- DISTINCT

Но замедляют:

- INSERT
- UPDATE
- DELETE

## 3. Как создаётся индекс

```sql
CREATE INDEX index_name
ON table_name (column_name);
```

Пример:

```sql
CREATE INDEX idx_employees_salary
ON employees (salary);
```

## 4. Первичный ключ и индекс

`PRIMARY KEY`

Автоматически создаёт:

- уникальный индекс
- ограничение уникальности

## 5. Типы индексов в PostgreSQL

PostgreSQL поддерживает несколько типов:

- B-Tree (по умолчанию)
- Hash
- GIN
- GiST
- BRIN

## 6. B-Tree

Используется по умолчанию.

Подходит для:

- `=`
- `<`, `>`
- `BETWEEN`
- `ORDER BY`

> Универсальный и самый часто используемый тип.

## 7. Hash

Подходит только для операций равенства (`=`)

Используется редко.

## 8. GIN

Подходит для:

- массивов
- JSONB
- полнотекстового поиска

## 9. GiST

Используется для:

- геоданных
- диапазонов
- сложных типов данных

## 10. BRIN

Подходит для:

- очень больших таблиц
- данных с естественной сортировкой (по дате, id)

Работает эффективно при:

- больших объёмах
- минимальной памяти

## 11. Составные (мультиколоночные) индексы

```sql
CREATE INDEX idx_orders_client_date
ON orders (client_id, order_date);
```

> Порядок столбцов имеет значение.

Используется, если фильтрация начинается с первого столбца

## 12. Уникальные индексы

```sql
CREATE UNIQUE INDEX idx_unique_email
ON users (email);
```

Гарантируют отсутствие дубликатов.

## 13. Частичные индексы

Создаются для части строк:

```sql
CREATE INDEX idx_active_clients
ON clients (city)
WHERE status = 'active';
```

> Ускоряют выборки по часто используемым условиям.

## 14. Индексы и EXPLAIN

Для анализа используется:

```sql
EXPLAIN ANALYZE SELECT ...
```


Показывает:

- Seq Scan
- Index Scan
- Bitmap Index Scan

## 15. Когда индекс НЕ используется

Индекс может не применяться, если:

- таблица маленькая
- используется функция на столбце
- условие не селективно
- статистика устарела

## 16. Индексы и функции

Если используется:

```sql
WHERE LOWER(name) = 'ivan'
```

Обычный индекс не работает.

Нужно создать функциональный индекс:

```sql
CREATE INDEX idx_lower_name
ON users (LOWER(name));
```

## 17. Индексы и производительность

Индекс ускоряет чтение, но:

- увеличивает размер БД
- замедляет вставку и обновление
- требует обслуживания

## 18. Избыточные индексы

Опасности:

- дублирующие индексы
- ненужные индексы
- чрезмерная нагрузка на запись

## 19. Как правильно выбирать индекс

Анализировать:

- какие запросы выполняются чаще
- по каким столбцам фильтрация
- селективность данных
- объём таблицы

## 20. Индексы и транзакции

Индексы:

- участвуют в блокировках
- могут влиять на deadlock
- используются при поиске строк для UPDATE

## 21. Типичные ошибки студентов

|Ошибка                                     | Причина           |
|-------------------------------------------|-------------------|
|Индекс на каждый столбец                   | Избыточность      |
|Игнорирование порядка в составном индексе  | Непонимание работы|
|Отсутствие анализа EXPLAIN                 | Нет проверки      |
|Индекс на маленькую таблицу                | Бесполезно        |

## 22. Выводы

Индексы:

- ускоряют поиск
- требуют осознанного проектирования
- влияют на производительность записи
- должны создаваться на основе анализа запросов

## Домашнее задание

Предметная область:

```sql
employees (id SERIAL PRIMARY KEY, full_name TEXT, salary NUMERIC, department TEXT);
orders (id SERIAL PRIMARY KEY, client_id INT, order_date DATE, total_amount NUMERIC);
clients (id SERIAL PRIMARY KEY, full_name TEXT, city TEXT, status TEXT);
```

> Заполните таблицы минимум 10 000 строками (для анализа производительности), можно использовать ИИ.

### Задание 1. Индекс и WHERE

Выполнить запрос:

```sql
EXPLAIN ANALYZE
SELECT * FROM employees WHERE salary > 100000;
```

Создать индекс по salary.

Повторить EXPLAIN ANALYZE.

> Сравнить:

> -тип сканирования

> -время выполнения

> -план запроса

### Задание 2. Составной индекс

Выполнить запрос:

```sql
SELECT * FROM orders
WHERE client_id = 10
AND order_date >= '2024-01-01';
```

Создать составной индекс (client_id, order_date).

Проанализировать план выполнения.

> Объяснить: почему порядок столбцов важен.

### Задание 3. Частичный индекс

Создать частичный индекс для:

```sql
WHERE status = 'active';
```

Выполнить запрос для активных клиентов.

Проверить использование индекса.

> Объяснить, в каких случаях частичный индекс выгоден.

### Задание 4. Функциональный индекс

Выполнить запрос:

```sql
SELECT * FROM clients
WHERE LOWER(full_name) = 'ivan ivanov';
```

Создать функциональный индекс.

Проверить план выполнения.

### Задание 5

Определить избыточные индексы в таблице (если создать несколько).

Обосновать, какие индексы можно удалить и почему.

Использовать анализ планов и частоты запросов.

### Контрольные вопросы

1. Что такое индекс и зачем он нужен?
2. Почему индекс ускоряет SELECT, но замедляет INSERT?
3. Какие типы индексов поддерживает PostgreSQL?
4. Чем отличается B-Tree от Hash?
5. Почему порядок столбцов важен в составном индексе?
6. Когда индекс может не использоваться?
7. Что такое частичный индекс и когда он полезен?
8. Что такое функциональный индекс?
9. Почему избыточные индексы вредны?
10. Как определить, используется ли индекс?